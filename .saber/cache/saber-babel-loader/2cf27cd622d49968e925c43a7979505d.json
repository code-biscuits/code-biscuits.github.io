{"ast":null,"code":"import Vue from 'vue';\nimport Router from 'vue-router';\nimport RoutePrefetch from 'vue-router-prefetch';\nimport routes from '#cache/routes';\nVue.use(Router); // Make `<RouterLink>` prefetch-able\n\nVue.use(RoutePrefetch, {\n  // Only enable prefetching in production mode\n  prefetch: process.env.NODE_ENV === 'production'\n});\n\nif (process.client) {\n  if ('scrollRestoration' in window.history) {\n    window.history.scrollRestoration = 'manual'; // reset scrollRestoration to auto when leaving page, allowing page reload\n    // and back-navigation from other pages to use the browser to restore the\n    // scrolling position.\n\n    window.addEventListener('beforeunload', function () {\n      window.history.scrollRestoration = 'auto';\n    }); // Setting scrollRestoration to manual again when returning to this page.\n\n    window.addEventListener('load', function () {\n      window.history.scrollRestoration = 'manual';\n    });\n  }\n}\n\nexport default (function () {\n  var createRouter = function createRouter(routes) {\n    return new Router({\n      mode: 'history',\n      routes: routes,\n      base: __PUBLIC_URL__,\n      scrollBehavior: function scrollBehavior(to, from, savedPosition) {\n        // if the returned position is falsy or an empty object,\n        // will retain current scroll position.\n        var position = false; // if no children detected and scrollToTop is not explicitly disabled\n\n        if (to.matched.length < 2 && to.matched.every(function (r) {\n          return r.components[\"default\"].scrollToTop !== false;\n        })) {\n          // scroll to the top of the page\n          position = {\n            x: 0,\n            y: 0\n          };\n        } else if (to.matched.some(function (r) {\n          return r.components[\"default\"].scrollToTop;\n        })) {\n          // if one of the children has scrollToTop option set to true\n          position = {\n            x: 0,\n            y: 0\n          };\n        } // savedPosition is only available for popstate navigations (back button)\n\n\n        if (savedPosition) {\n          position = savedPosition;\n        }\n\n        return new Promise(function (resolve) {\n          var fulfill = function fulfill() {\n            // coords will be used if no selector is provided,\n            // or if the selector didn't match any element.\n            if (to.hash) {\n              var hash = decodeURIComponent(to.hash);\n\n              if (document.getElementById(hash.substr(1))) {\n                // scroll to anchor by returning the selector\n                position = {\n                  selector: hash\n                };\n              } else {\n                // scroll to top if anchor does not exist and position is not already set\n                position = position || {\n                  x: 0,\n                  y: 0\n                };\n              }\n            }\n\n            resolve(position);\n          }; // wait for the out transition to complete (if necessary)\n\n\n          if (to.path === from.path) {\n            fulfill();\n          } else {\n            router.app.$once('trigger-scroll', fulfill);\n          }\n        });\n      }\n    });\n  };\n\n  var router = createRouter(routes);\n\n  if (__LAZY__) {\n    var hasPrevPage = false;\n    var visitedRoutes = {};\n    router.beforeEach(function (to, from, next) {\n      if (!hasPrevPage || visitedRoutes[to.path]) return next();\n      next(false);\n      visitedRoutes[to.path] = true;\n      fetch(\"/_saber/visit-page?id=\".concat(window.__SABER_DEV_CLIENT_ID__, \"&route=\").concat(encodeURIComponent(to.fullPath)));\n    });\n    router.afterEach(function () {\n      hasPrevPage = true;\n    });\n  }\n\n  if (module.hot) {\n    module.hot.accept('#cache/routes', function () {\n      router.options.routes = routes;\n      router.matcher = createRouter(require('#cache/routes')[\"default\"]).matcher;\n    });\n  }\n\n  return router;\n});","map":null,"metadata":{},"sourceType":"module"}