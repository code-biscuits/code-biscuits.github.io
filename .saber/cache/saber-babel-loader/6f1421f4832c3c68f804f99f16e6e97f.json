{"ast":null,"code":"import Vue from 'vue';\nimport Router from 'vue-router';\nimport RoutePrefetch from 'vue-router-prefetch';\nimport routes from '#cache/routes';\nVue.use(Router); // Make `<RouterLink>` prefetch-able\n\nVue.use(RoutePrefetch, {\n  // Only enable prefetching in production mode\n  prefetch: process.env.NODE_ENV === 'production'\n});\n\nif (process.client) {\n  if ('scrollRestoration' in window.history) {\n    window.history.scrollRestoration = 'manual'; // reset scrollRestoration to auto when leaving page, allowing page reload\n    // and back-navigation from other pages to use the browser to restore the\n    // scrolling position.\n\n    window.addEventListener('beforeunload', function () {\n      window.history.scrollRestoration = 'auto';\n    }); // Setting scrollRestoration to manual again when returning to this page.\n\n    window.addEventListener('load', function () {\n      window.history.scrollRestoration = 'manual';\n    });\n  }\n}\n\nexport default (function () {\n  var createRouter = function createRouter(routes) {\n    return new Router({\n      mode: 'history',\n      routes: routes,\n      base: __PUBLIC_URL__,\n      scrollBehavior: function scrollBehavior(to, from, savedPosition) {\n        // if the returned position is falsy or an empty object,\n        // will retain current scroll position.\n        var position = false; // if no children detected and scrollToTop is not explicitly disabled\n\n        if (to.matched.length < 2 && to.matched.every(function (r) {\n          return r.components[\"default\"].scrollToTop !== false;\n        })) {\n          // scroll to the top of the page\n          position = {\n            x: 0,\n            y: 0\n          };\n        } else if (to.matched.some(function (r) {\n          return r.components[\"default\"].scrollToTop;\n        })) {\n          // if one of the children has scrollToTop option set to true\n          position = {\n            x: 0,\n            y: 0\n          };\n        } // savedPosition is only available for popstate navigations (back button)\n\n\n        if (savedPosition) {\n          position = savedPosition;\n        }\n\n        return new Promise(function (resolve) {\n          var fulfill = function fulfill() {\n            // coords will be used if no selector is provided,\n            // or if the selector didn't match any element.\n            if (to.hash) {\n              var hash = decodeURIComponent(to.hash);\n\n              if (document.getElementById(hash.substr(1))) {\n                // scroll to anchor by returning the selector\n                position = {\n                  selector: hash\n                };\n              } else {\n                // scroll to top if anchor does not exist and position is not already set\n                position = position || {\n                  x: 0,\n                  y: 0\n                };\n              }\n            }\n\n            resolve(position);\n          }; // wait for the out transition to complete (if necessary)\n\n\n          if (to.path === from.path) {\n            fulfill();\n          } else {\n            router.app.$once('trigger-scroll', fulfill);\n          }\n        });\n      }\n    });\n  };\n\n  var router = createRouter(routes);\n\n  if (__LAZY__) {\n    var hasPrevPage = false;\n    var visitedRoutes = {};\n    router.beforeEach(function (to, from, next) {\n      if (!hasPrevPage || visitedRoutes[to.path]) return next();\n      next(false);\n      visitedRoutes[to.path] = true;\n      fetch(\"/_saber/visit-page?id=\".concat(window.__SABER_DEV_CLIENT_ID__, \"&route=\").concat(encodeURIComponent(to.fullPath)));\n    });\n    router.afterEach(function () {\n      hasPrevPage = true;\n    });\n  }\n\n  if (module.hot) {\n    module.hot.accept('#cache/routes', function () {\n      router.options.routes = routes;\n      router.matcher = createRouter(require('#cache/routes')[\"default\"]).matcher;\n    });\n  }\n\n  return router;\n});","map":{"version":3,"sources":["/Users/cmgriffing/code-biscuits.github.io/node_modules/saber/vue-app/router.js"],"names":["Vue","Router","RoutePrefetch","routes","use","prefetch","process","env","NODE_ENV","client","window","history","scrollRestoration","addEventListener","createRouter","mode","base","__PUBLIC_URL__","scrollBehavior","to","from","savedPosition","position","matched","length","every","r","components","scrollToTop","x","y","some","Promise","resolve","fulfill","hash","decodeURIComponent","document","getElementById","substr","selector","path","router","app","$once","__LAZY__","hasPrevPage","visitedRoutes","beforeEach","next","fetch","__SABER_DEV_CLIENT_ID__","encodeURIComponent","fullPath","afterEach","module","hot","accept","options","matcher","require"],"mappings":"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","sourcesContent":["import Vue from 'vue'\nimport Router from 'vue-router'\nimport RoutePrefetch from 'vue-router-prefetch'\nimport routes from '#cache/routes'\n\nVue.use(Router)\n// Make `<RouterLink>` prefetch-able\nVue.use(RoutePrefetch, {\n  // Only enable prefetching in production mode\n  prefetch: process.env.NODE_ENV === 'production'\n})\n\nif (process.client) {\n  if ('scrollRestoration' in window.history) {\n    window.history.scrollRestoration = 'manual'\n\n    // reset scrollRestoration to auto when leaving page, allowing page reload\n    // and back-navigation from other pages to use the browser to restore the\n    // scrolling position.\n    window.addEventListener('beforeunload', () => {\n      window.history.scrollRestoration = 'auto'\n    })\n\n    // Setting scrollRestoration to manual again when returning to this page.\n    window.addEventListener('load', () => {\n      window.history.scrollRestoration = 'manual'\n    })\n  }\n}\n\nexport default () => {\n  const createRouter = routes =>\n    new Router({\n      mode: 'history',\n      routes,\n      base: __PUBLIC_URL__,\n      scrollBehavior(to, from, savedPosition) {\n        // if the returned position is falsy or an empty object,\n        // will retain current scroll position.\n        let position = false\n\n        // if no children detected and scrollToTop is not explicitly disabled\n        if (\n          to.matched.length < 2 &&\n          to.matched.every(r => r.components.default.scrollToTop !== false)\n        ) {\n          // scroll to the top of the page\n          position = { x: 0, y: 0 }\n        } else if (to.matched.some(r => r.components.default.scrollToTop)) {\n          // if one of the children has scrollToTop option set to true\n          position = { x: 0, y: 0 }\n        }\n\n        // savedPosition is only available for popstate navigations (back button)\n        if (savedPosition) {\n          position = savedPosition\n        }\n\n        return new Promise(resolve => {\n          const fulfill = () => {\n            // coords will be used if no selector is provided,\n            // or if the selector didn't match any element.\n            if (to.hash) {\n              const hash = decodeURIComponent(to.hash)\n              if (document.getElementById(hash.substr(1))) {\n                // scroll to anchor by returning the selector\n                position = { selector: hash }\n              } else {\n                // scroll to top if anchor does not exist and position is not already set\n                position = position || { x: 0, y: 0 }\n              }\n            }\n\n            resolve(position)\n          }\n\n          // wait for the out transition to complete (if necessary)\n          if (to.path === from.path) {\n            fulfill()\n          } else {\n            router.app.$once('trigger-scroll', fulfill)\n          }\n        })\n      }\n    })\n\n  const router = createRouter(routes)\n\n  if (__LAZY__) {\n    let hasPrevPage = false\n    const visitedRoutes = {}\n\n    router.beforeEach((to, from, next) => {\n      if (!hasPrevPage || visitedRoutes[to.path]) return next()\n\n      next(false)\n\n      visitedRoutes[to.path] = true\n      fetch(\n        `/_saber/visit-page?id=${\n          window.__SABER_DEV_CLIENT_ID__\n        }&route=${encodeURIComponent(to.fullPath)}`\n      )\n    })\n\n    router.afterEach(() => {\n      hasPrevPage = true\n    })\n  }\n\n  if (module.hot) {\n    module.hot.accept('#cache/routes', () => {\n      router.options.routes = routes\n      router.matcher = createRouter(require('#cache/routes').default).matcher\n    })\n  }\n\n  return router\n}\n"]},"metadata":{},"sourceType":"module"}